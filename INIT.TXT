;;;;; An Initial Program for UrLISP ;;;;;;
;; Version 0.9.0
;; 2025 Tsugu
;;;;;

; -------------------------------------
;; System Categories:
;  Dynamic Scope, Lisp-1
;  TRO (tail recursion optimization) supported.
;  (This document aims to present a software solution for TRO.)

;; Supported Functions & Special Forms:
;  quote('), atom, eq, car, cdr, cons, cond, label, lambda,
;  rplaca, rplacd, eval_,
;  def, setq, while, do-while, error,
;  num(#), len(#=), gc, importenv, exportenv,
;  quit, cls, read, display, prompt verbos

; -------------------------------------
;; Usage

; "Super Brakets" '[' and ']'
'(a (b (c]          ; ==> (a (b (c)))
'(a [b (c] [b (c])  ; ==> (a (b (c)) (b (c)))

; 'importenv', 'exportenv'
(exportenv)             ; ==> nil
(importenv '((x . a)))  ; ==> t
(exportenv)             ; ==> ((x . a))
x                       ; ==> a

; 'def' writes the definition into the global environment,
; regardless of what scope it is declared in.
(def y 'b)   ; ==> y
(exportenv)  ; ==> ((y . b) (x . a))
x            ; ==> a
y            ; ==> b

; 'setq'
(setq a '200)  ; ==> "Not found: a"
(def a '100)
(setq a '200)
a  ; ==> 200

; Truth, False
(eq 'a 'a)  ; ==> t
(eq 'a 'b)  ; ==> nil

; 'begin'
(begin (setq a '100) a) ; ==> 100

; Gabage Collection
(gc)

; Show garbage collection initiation.
(verbos '())
(gc)  ; ==>
(verbos 't)
(gc)  ; ==> .

; Initializing of the environment list
(importenv '())

; Screen Clear
; (cls)

; Exit UrLISP
; (quit)

; Display Errors
(error '1 'exp)  ; ==> "Not found: exp"
(error '2 'exp)  ; ==> "Invalid form: exp"
(error '3 'exp)  ; ==> "Error: exp"

; Read a S-expression
(read)
(cdr
 (1 2 3))
; ==> (cdr (quote (1 2 3)))

; Display a S-expression
(display (cdr '(1 2 3)))  ; ==> (2 3)(2 3)
                          ;          ^^^^^
                          ;          return
(display '\0)  ; ==> no character
(display '\s)  ; ==> a white space
(display '\n)  ; ==> a new line

; Set the prompt
(prompt '>>)  ; The prompt is '>>'.
(prompt '>)   ; The prompt is '>'.

; num
(num 6)  ; ==> (t t t t t t)
#6       ; ==> (t t t t t t)

; len
(len '(a a a b b))  ; ==> 5
#='(a a a b b)      ; ==> 5

; #' (Shorthand only. The "function" is not implemented.)
'#'aaa  ; ==> '(function aaa) ==> (function aaa)

; =====================================
;; Basic Functions

(def caar '(lambda (x) (car (car x))))
(def cadr '(lambda (x) (car (cdr x))))
(def cdar '(lambda (x) (cdr (car x))))
(def cddr '(lambda (x) (cdr (cdr x))))
(def caaar '(lambda (x) (car (caar x))))
(def caadr '(lambda (x) (car (cadr x))))
(def cadar '(lambda (x) (car (cdar x))))
(def caddr '(lambda (x) (car (cddr x))))
(def cdaar '(lambda (x) (cdr (caar x))))
(def cdadr '(lambda (x) (cdr (cadr x))))
(def cddar '(lambda (x) (cdr (cdar x))))
(def cdddr '(lambda (x) (cdr (cddr x))))

(def list
  '(lambda x x))

(def null
  '(lambda (x) (eq x '())))

(def not
  '(lambda (x)
     (cond (x '()) (t 't))))

(def rev-append
  ' (lambda (x y)
      (cond ((null x) y)
            (t (rev-append (cdr x) (cons (car x) y))))))

(def reverse
  '(lambda (x) (rev-append x '())))

(def append
  '(lambda (x y)
     (rev-append (rev-append x '()) y)))

(def pairlis*
  '(lambda (v e a)
     (cond ((null v) a)
           ((atom v) (list (cons v e)))
           (t (cons (cons (car v) (car e))
                    (pairlis* (cdr v) (cdr e) a))))))

(def assoc*
  '(lambda (x a)
     (cond ((null a) (error '1 x))
           ((eq x (caar a)) (car a))
           (t (assoc* x (cdr a))))))

(def isSUBR
  '(lambda (x)
     (cond ((eq x 'atom) 't)
           ((eq x 'eq) 't)
           ((eq x 'car) 't)
           ((eq x 'cdr) 't)
           ((eq x 'cons) 't)
           ((eq x 'len) 't)
           ((eq x 'error) 't)
           (t '()))))

; =====================================
;;; Line Lisp


; (block '(< < 1 2 3 > 4 5 > 6 7)) ==> ((< < 1 2 3 > 4 5 >) < 6 7)
; (block '(< < 1 2 3 > 4 5)) ==> ()
; (block '(1 ! 2 3)) ==> (1 . 2)
; (block '(1 2 3 4 5)) ==> (1 < 2 3 4 5)
(def block
  '(lambda (exp)
     (cond ((eq '< (car exp))
            (block-rec '(<) (list (car exp)) (cdr exp)))
           (t
            (cond ((eq '! (cadr exp)) (cons (car exp) (caddr exp)))
                  (t (cons (car exp) (cons '< (cdr exp)))))))))


(def block-rec
  '(lambda (stack done exp)
     (cond
       ((null exp)
        (cond
          ((null stack) (cons (reverse done) exp))
          (t '())))  ; irregular list
       ((null stack)
        (cond
          ((null done) exp)
          (t
           (cond
             ((eq '! (car exp)) (cons (reverse done) (cadr exp)))
             (t (cons (reverse done) (cons '< exp)))))))
       ((eq '< (car exp))
        (block-rec (cons '< stack) (cons (car exp) done) (cdr exp)))
       ((eq '> (car exp))
        (block-rec (cdr stack) (cons (car exp) done) (cdr exp)))
       (t
        (block-rec stack (cons (car exp) done) (cdr exp))))))

(def car<
  '(lambda (x)
     (cond ((eq '< (car x))
            (cond ((eq '! (cadr x)) (car '()))
                  ((eq '> (cadr x)) (car '()))
                  (t (car (block (cdr x))))))
           (t (car x)))))

(def cdr<
  '(lambda (x)
     (cond ((eq '< (car x))
            (cond
              ((eq '! (cadr x)) (cdr '()))
              ((eq '> (cadr x)) (cdr '()))
              ((atom (cdr (block (cdr x)))) (cdr (block (cdr x))))
              (t
               (cond ((eq '> (caddr (block (cdr x)))) '())
                     (t (cdr (block (cdr x))))))))
           (t (cdr x)))))

(def conect
  '(lambda (x y)
     (cond ((atom x) (cons x y))
           (t (append x y)))))

(def cons<
  '(lambda (x y)
     (cond
       ((atom y)
        (cond ((null y) (cons '< (conect x '(>))))
              (t (cons '< (conect x (list '! y '>))))))
       ((eq '< (car y))
        (cons '< (conect x (cdr y))))
       (t (cons '< (append (cons x y) '(>)))))))

(def caar< '(lambda (x) (car< (car< x))))
(def cadr< '(lambda (x) (car< (cdr< x))))
(def cdar< '(lambda (x) (cdr< (car< x))))
(def cddr< '(lambda (x) (cdr< (cdr< x))))
(def caaar< '(lambda (x) (car< (caar< x))))
(def caadr< '(lambda (x) (car< (cadr< x))))
(def cadar< '(lambda (x) (car< (cdar< x))))
(def caddr< '(lambda (x) (car< (cddr< x))))
(def cdaar< '(lambda (x) (cdr< (caar< x))))
(def cdadr< '(lambda (x) (cdr< (cadr< x))))
(def cddar< '(lambda (x) (cdr< (cdar< x))))
(def cdddr< '(lambda (x) (cdr< (cddr< x))))

; (pairlis< '(< x y >) '(< 1 2 >) '(< < z ! 3 > >))
;  ==> (< < x ! 1 > < y ! 2 > < z ! 3 > >)
; (pairlis< '(< x y ! z >) '(< 1 2 3 4 5 >) '())
;  ==> (< < x ! 1 > < y ! 2 > < z 3 4 5 > >)
(def pairlis<
  '(lambda(v e a)
     (cond
       ((null v) a)
       ((atom v) (cons< (cons< v e) a))
       (t (cons< (cons< (car< v) (car< e))
                 (pairlis< (cdr< v) (cdr< e) a))))))

(def assoc<
  '(lambda (x a)
     (cond ((null a) (error '1 x))
           ((eq x (caar< a)) (car< a))
           (t (assoc< x (cdr< a))))))

(def eval<
  '(lambda (e a)
     (cond
       ((eq e 't) 't)
       ((eq e '()) '())
       ((atom e) (cdr< (assoc< e a)))
       ((isSUBR (car< e)) (apply< (car< e) (evlis< (cdr< e) a) a))
       ((atom (car< e)) (apply< (car< e) (cdr< e) a))
       ((eq (caar< e) 'lambda) (apply< (car< e) (evlis< (cdr< e) a) a))
       (t (apply< (car< e) (cdr< e) a)))))

(def apply<
  '(lambda (fn args a)
     (cond
       ((atom fn)
        (cond
          ((eq fn 'quote) (car< args))
          ((eq fn 'atom) (atom (car< args)))
          ((eq fn 'eq) (eq (car< args) (cadr< args)))
          ((eq fn 'car) (car< (car< args)))
          ((eq fn 'cdr) (cdr< (car< args)))
          ((eq fn 'cons) (cons< (car< args) (cadr< args)))
          ((eq fn 'cond) (evcon< args a))
          ((eq fn 'error) (error (car< args) (cadr< args)))
          (t (eval< (cons< (cdr< (assoc< fn a)) args) a))))
       ((eq (car< fn) 'label)
        (eval< (cons< (caddr< fn) args)
               (cons< (cons< (cadr< fn) (caddr< fn)) a)))
       ((eq (car< fn) 'lambda)
        (eval< (caddr< fn) (pairlis< (cadr< fn) args a)))
       (t (error '2 (cons< fn args))))))

(def evcon<
  '(lambda (c a)
     (cond ((null (eval< (caar< c) a)) (evcon< (cdr< c) a))
           (t (eval< (cadar< c) a)))))

(def evlis<
  '(lambda (m a)
     (cond ((null m) '())
           (t (cons< (eval< (car< m) a) (evlis< (cdr< m) a))))))

; =====================================
;; Virtual REPL (for Line Lisp)

; The global environment list '*env<*'
(def *env<* '(< < *env<* > >))

; Add (x . y) to *env<*.
(def <<<
  '(lambda (x y)
     (begin
       (setq *env<* (cons< (cons< '*env<* (cons< (cons< x y) (cdr< *env<*)))
                           (cons< (cons< x y) (cdr< *env<*))))
       x)))

; Eval x on the environment "*env<*".
(def >> '(lambda (an_eval x) (an_eval x *env<*)))

; Import an environment.
(def importenv<!
  '(lambda (env)
     (begin
       (setq *env<* (cons< (cons< '*env<* env) env))
       't)))

; Export the environment "*env<*".
(def exportenv!
  '(lambda () *env<*))

; Reset the environment "*env<*".
(def resetenv<!
  '(lambda ()
     (begin
       (setq *env<* '(< < *env<* > >))
       t)))

; The holder of the top level S-expression
(def *top* '(()))

; Virtual REPL
;
(def repl-body<
  '(lambda (an_eval exp)
     (begin
       (cond
         ((not (atom exp))
          (cond
            ((eq 'importenv (car exp))
             (display (importenv<! (eval_ (cadr exp) (exportenv)))))
            ((eq 'exportenv (car exp))
             (display (exportenv!)))
            ((eq 'resetenv (car exp))
             (display (resetenv<!)))
            ((eq 'def (car exp))
             (display (<<< (cadr exp) (eval< (caddr exp) *env<*))))
            (t (display (>> an_eval exp)))))
         (t (display (>> an_eval exp))))
       (display '\n))))
;
(def read-top
  '(lambda ()
     (begin
       (prompt '%)
       (rplaca *top* (read))
       (prompt '>)
       '\0)))
;
(def repl-loop<
  '(lambda (an_eval)
     (begin
       (repl-body< an_eval (car *top*))
       (repl< an_eval))))
;
(def repl<
  '(lambda args
     (begin
       (cond ((null args) (setq args '(eval<))))
       (read-top)
       (cond
         ((atom (car *top*)) (repl-loop< (car args)))
         ((eq 'exit (car (car *top*))) 'ok)
         (t (repl-loop< (car args)))))))

; =====================================
;; A meta-circular pure LISP program "plisp 1.5"
;  (Line Lisp version)

(def plisp1!5
  '(<
    < caar lambda < x > < car < car x > > >
    < cadr lambda < x > < car < cdr x > > >
    < cdar lambda < x > < cdr < car x > > >
    < cddr lambda < x > < cdr < cdr x > > >
    < caaar lambda < x > < car < caar x > > >
    < caadr lambda < x > < car < cadr x > > >
    < cadar lambda < x > < car < cdar x > > >
    < caddr lambda < x > < car < cddr x > > >
    < cdaar lambda < x > < cdr < caar x > > >
    < cdadr lambda < x > < cdr < cadr x > > >
    < cddar lambda < x > < cdr < cdar x > > >
    < cdddr lambda < x > < cdr < cddr x > > >
    < null
       lambda < x > < eq x () > >
    < not
       lambda < x >
         < cond < x () > < t t > > >
    < pairlis
       lambda < v e a >
         < cond < < null v > a >
                < < atom v > < cons < cons v e > a > >
                < t < cons < cons < car v > < car e > >
                           < pairlis < cdr v > < cdr e > a > > > > >
    < assoc
       lambda < x a >
         < cond < < null a > < error < quote 1 > x > >
                < < eq x < caar a > > < car a > >
                < t < assoc x < cdr a > > > > >
    ; < error
    ;    lambda < err-code s-exp >
    ;      < Return a nil with outputing an error code and a S-expression. > >
    < isSUBR
       lambda < x >
         < cond < < eq x < quote atom > > t >
                < < eq x < quote eq > > t >
                < < eq x < quote car > > t >
                < < eq x < quote cdr > > t >
                < < eq x < quote cons > > t >
                < < eq x < quote error > > t >
                < t () > > >
    < eval
       lambda < e a >
         < cond
           < < eq e < quote t > > < quote t > >
           < < eq e < quote () > > < quote () > >
           < < atom e > < cdr < assoc e a > > >
           < < isSUBR < car e > > < apply < car e > < evlis < cdr e > a > a > >
           < < atom < car e > > < apply < car e > < cdr e > a > >
           < < eq < caar e > < quote lambda > > < apply < car e > < evlis < cdr e > a > a > >
           < t < apply < car e > < cdr e > a > > > >
    < apply
       lambda < fn args a >
         < cond
           < < atom fn >
             < cond
               < < eq fn < quote quote > > < car args > >
               < < eq fn < quote atom > > < atom < car args > > >
               < < eq fn < quote eq > > < eq < car args > < cadr args > > >
               < < eq fn < quote car > > < car < car args > > >
               < < eq fn < quote cdr > > < cdr < car args > > >
               < < eq fn < quote cons > > < cons < car args > < cadr args > > >
               < < eq fn < quote cond > > < evcon args a > >
               < < eq fn < quote error > > < error < car args > < cadr args > > >
               < t < eval < cons < cdr < assoc fn a > > args > a > > > >
           < < eq < car fn > < quote label > >
             < eval < cons < caddr fn > args >
                    < cons < cons < cadr fn > < caddr fn > > a > > >
           < < eq < car fn > < quote lambda > >
             < eval < caddr fn > < pairlis < cadr fn > args a > > >
           < t < error < quote 2 > < cons fn args > > > > >
    < evcon
       lambda < c a >
         < cond < < null < eval < caar c > a > > < evcon < cdr c > a > >
                < t < eval < cadar c > a > > > >
    < evlis
       lambda < m a >
         < cond < < null m > () >
                < t < cons < eval < car m > a > < evlis < cdr m > a > > > > >
    >))

; =====================================
'TEST_1

(verbos 't)
(repl<)

(def reverse
  (< quote
     < lambda < x >
       < < label
           rec
           < lambda < x y >
           < cond
             < < eq () x >
               y >
             < t
               < rec < cdr x >
                     < cons < car x > y > > > > > >
         x () > > >))

(def subst
  (< quote
     < label
       subst
       < lambda < x y z >
           < cond
             < < atom z >
               < cond
                 < < eq z y >
                   x >
                 < t
                   z > > >
             < t
               < cons < subst x y < car z > >
                      < subst x y < cdr z > > > > > > > >))

(< reverse < quote < 1 2 3 4 5 > > > >)
(< subst < quote m > < quote b > < quote < a b < a b c > d > > > >)
(exit)

; -------------------------------------
'Test_2
;; Warning. Very slow.

; (verbos 't)
; (repl<)
; (importenv plisp1!5)

; (def list (< quote < lambda x x > >))

; (< eval < quote < list < quote a > < quote b > > > *env<* >)
; (exit)

; -------------------------------------
'Test_3

(def infloop
  '(lambda () (infloop2)))
(def infloop2
  '(lambda () (infloop)))
(verbos 't)
; (infloop)
;;   -->  TRO achieved! Please press Ctrl+C.
